# 多维数组

林璐霞 18377149

* 其实我在二维数组的时候就顺便实现了任意多维的数组，二维的性质常常跟更高维是一样的（比如二重积分）。而且实现了任意维的时候，不需要再专门考虑一维了。在函数的lab8中，也实现了能传的参数也是任意多维的。这里写的内容差不多就是我原来lab7和lab8的总结吧。
* 我的实现基本都是自己参考将程序用clang编译之后的结果，使用了llvm的实现方式（没有用一维数组模拟）。事实上我怀疑明白llvm ir的`getelementptr`在干嘛之后，这样的方式会在多维数组解引用，参数传递等方面比一维数组方便的多。且与C语言一致。
* 其实llvm ir有些地方也没有特别懂，但是写几个例子丢给clang生成一下，看看结果模仿着也能写出来。

### 类型

* 首先，我增加了个两个新的类型：指针以及数组。
  * 数组的表示方式是一个列表，其中内容为各维的长度，如数组`a[2][3][4]`在我的实现中类型是`'(2 3 4)`
  * 指针只有在数组中使用，是在函数调用中将数组当做指针传。可以理解成没有长度信息的数组。因此表示和数组相似，只是将原来放长度信息的部分用一个symbol`'ptr`表示，`int a[2][3][4]`中，`a[2]`被表示为`'(ptr 3 4)`。
  * 另外，这其实隐含了，`'()`这样的空数组应该被翻译成`i32`（考虑到BType只有int）。但也懒得去改前面了。

### 初始化

* 初始化需要分成全局变量和局部变量两部分实现。初始化的值第一步都是得到不完整的列表，然后对全局变量会进行补全，局部变量会一个个递归使用store保存初始值。

* 全局变量：

  * 考虑到由于const的全局数组的元素需要被当作编译时知道的，所以虽然可以在部分使用zeroinitializer，但还是选择自己写了个递归函数（见下）把所有空缺的0都补上。而且全局变量初始化的时候，需要给齐所有需要的变量，因此写了一个函数，传入数组形状和已有的初始值，会返回对齐了的数组，效果比如比如`a[100][2]={{10}}`，传入形状为`'(100)`，初始值为`'((10))`，返回一个`'((10 0 0 ... 0)(0 .. 0))'`。

  * ```lisp
    ; 返回将有省略0的数组初始值补充上所有0后的结果。
    ; shape -> 数组的形状，要求是一个列表，如'(1 2 3)
    ; value -> 当前的（可能不完整的）数组初始值
    (define (implement-const shape value)
      ; iter返回结果应该是一个列表，元素个数与shape的首元素相等。
      ; 如：shape为'(2 3 4)，返回结果的列表有两个元素，这两个元素均是形状为'(3 4)的数组的初始值。
      (define (iter shape value)
        ; 是否是最后一层了
        (if (empty? shape)
            ; 是最后一层就只需要输出原来给的初始值
        		; 没给（传入的value是空列表'()）返回0
            (if (empty? value) 0 value)
            ; 如果不是最后一层，则依次将列表补齐，需要生成shape队首元素要求的那么多个子数组。
            (let loop ([len (car shape)]
                       [child-shape (cdr shape)]
                       [init value])
              (if (equal? 0 len) ; 判断遍历是否完成
                  '() ; 完成则返回一个空列表
                  (cons 
                   ; 没完成的话，返回的其实是当前的数组子元素，然后接上后面的数组子元素的列表。
                   ; 如：shape为'(6 3 4)，第一次进入的时候len为6，那么我需要的就是，第一个子元素形状为(3 4)，然后接上后面的五个同样形状的子元素，而后面接上的部分其实就是补全一个形状为'(5 3 4)的数组元素
                   (iter child-shape 
                         (if (empty? init) '() (car init)))
                        (loop (- len 1) child-shape 
                              (if (empty? init) 
                                  '() 
                                  (cdr init))))))))
      (iter shape value))
    ```

  * 对于完全没有给定初值的非const数组（`a[100]={}`算给了，会被自动补齐成100个0的列表，`a[100]`这样的才算没给），使用的是`zeroinitializer`，反正我也不存。

* 局部变量：
  * 局部变量的初始化有两步，第一步先申请内存后，用memset将内容全都初始化成0，第二步是一个个将给了初值的元素使用store填进去。
  * 初始的置零也是使用`memset`。第一个参数，即块的指针，是通过`bitcast`实现的，将数组的指针转为`i32*`。然后用memset初始化，初始的长度为$4\times\Pi$​(各维长度)，其中4是`i32`的字节数。（参考clang的编译结果写的）
  * 使用的递归函数。遇到一个花括号，先使用解引用`getelementptr`一层数组，将解引用得到的变量名传入下一层递归；当遇到数字的时候就使用`store`来赋值。（Racket没有循环只有递归可能是我当初直接写了高维版本的动力。。。毕竟递归就不用考虑几层了，两层也是递归。。不如全搞了）

* 另外，还需要检查数组维数是否小于等于0，如果有则需要报错。



#### `LVal`：

* 这里也和LLVM一致，没有把高维数组当作一维数组实现。因为懒得自己算变成一维数组之后是第几个。加入函数后需要考虑有两种情况，数组可能给的是一个指针，或者是简单的数组而已。

* 数组：

  * 在`LVal`中对变量名解引用时。每遇到一对方括号，就使用`getelementptr`解引用一层。
  * `LVal`本来得到的就是一个指针。如果需要LVal存的值的话，会在primary那一个`load`得到值。

* 指针：

  * 如果需要解引用一个指针，那么变量里存的应该是指针的指针。首先需要将数组的指针的指针load，变成数组的指针，然后之前的普通的数组在`getelementptr`，第一组偏移量一直是0，因为不需要对数组的指针进行啥偏移，如int a[3]取a[3]只需要对a取第3个元素。但是对一个指针来说，需要做指针的便宜，int * a被当作数组，取第三个元素，就得是*(a + 3)。但是不需要解引用一层了。

  * 因此在实现生成`getelemptr`的语句的时候，就有两种情况：

  * ```lisp
    (define (generate-get-ptr shape ptr pos counter)
      (define type (get-llvm-type shape))
      (define id (get-llvm-var counter))
      (define id2 (get-llvm-var counter))
      
      (if (equal? 'ptr (car shape))
          ; 情况二：得到的是一个指针
          (list
           ; 首先需要把这指针的指针load成一个指针
           (list 'void id2 '= 'load type "," type '* ptr)
           (cons
            (if (empty? (cdr shape)) 'i32 (cdr shape))
            ; 并且偏移的时候只需要一个偏移量
            (flatten(list
                     id '=
                     'getelementptr  (get-llvm-type (cdr shape))
                     "," (get-llvm-type (cdr shape)) '* id2 ","
                     (list 'i32 pos)))))
          ; 情况一：得到的是数组，就是正常情况，getelemenetptr后面跟两个偏移量，第一个总是0.
          (list (cons
                 (if (empty? (cdr shape)) 'i32 (cdr shape))
                 (flatten(list
                          id '=
                          'getelementptr type "," type '* ptr ","
                          (list 'i32 0 "," 'i32 pos )))))))
    ```

  

#### 数组作为函数参数：

* 这一部分实现在`PrimaryExp`这个子函数中。增加了判断LVal传上来的是不是一个数组，如果还是数组的话，使用`getelemptr`，偏移0，0，将数组变成指针。