# Lab5

林璐霞 18377149

## Part8

### 实现

​	这部分由于之前预留好了数据结构，所以直接Part7啥也没改就过了。

* 每个block的符号表用一个哈希表保存，每当执行一个`Block`的子函数，都会得到一个新的哈希表。
* 每个子函数都会得到一个叫做`symbols`的参数。这个参数实际上是一个符号表哈希的列表（其实差不多是栈，先进后出，只是可以读中间的），将每层的符号表都一起传递进来。越内层的符号表越靠近列表头部（由于racket语言中，列表就是链表，这样的顺序会减少检索时间）。
  * 每次定义一个新的变量的时候，会先检查`symbols`中第一个符号表中是否已经有定义这个变量，如果有，则报错；否则加入第一个符号表中。
  * 每次需要引用一个变量的时候，从头开始往后找，直到遇到第一个含有该符号的符号表，得到值。如果都没有，则报错：符号未定义。
  * 每当一个Block结束的时候，就会有一个类似pop的操作。具体实现的时候其实没有pop操作。因为racket的语法上，列表是常量的链表。每次执行Block的时候，会在列表开头增加一个新的符号表，然后将新的头部传递到子函数中。Block外层的函数并不会知道他们得到的`symbols`的头部并不是第一个。子函数也没有办法删除这个链表中间的节点。

## Part9

### 实现

* 将当前的变量加入符号表是非常容易的，在Part8就实现好了（第一个符号表其实不是在block中创建的，而是在CompUnit中就创建了，提供给全局变量以及函数）。但还没办法计算全局变量初始化的右值。这里已经不能直接传给现在有的子函数来使用load和store赋初值了。因此新开了一个文件，叫做`cal-const.rkt`。在这个文件提供了两个对外的函数：`registe-var`和`cal-const`。这两个函数就可以完成全局变量的初始化。
  * `registe-var`是用来记录常量的全局变量的值的。只有常值的全局变量才可以给其他全局变量初始化。
  * `cal-const`的参数是一个抽象语法树，返回这个抽象语法树的计算结果。AST中可以包含变量名，`cal-const`会自动去`registe-var`注册过的变量中找。
* 具体的实现为：
  * `cal-const`中实现了一套新的递归子程序，用来计算值。如果有无法计算的部分，则报错。
  * 有一个全局的hash表，用来保存`registe-var`注册的全局常量。变量名只允许是在hash中注册过的。