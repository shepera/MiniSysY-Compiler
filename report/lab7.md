# Lab7

林璐霞 18377149

## Part12

### 实现

* 使用了LLVM IR 中的数组初始化和引用方式。因为感觉比一维数组简单，不需要自己算变成一维数组之后引用的是第几个。
* 其实我在这一部分实现的是任意维度的数组，二维数组和更高维数组好像是一回事，所以顺便实现了。
* 增加了一个数组类型，如果类型字段是一个数组，则当作数组类型，类型字段的数组保存的是数组各个维的长度。写了一个函数，传递数组维数，返回llvm中的数组类型。如传入`'(2 3)`，返回`[2 x [3 x i32]]`。
* 另外，还需要检查数组维数是否小于等于0，如果有则需要报错。
* 数组的初始化需要分成两个部分，全局变量和局部变量。除此之外，还有一个`LVal`需要实现，即数组的引用。

#### 全局变量：

* 全局数组变量还是基于全局变量完善。加入判断是否有`[][]`的部分，如果有则是数组。
* 由于const的全局数组还是需要在本地存一份，以后的其他初始化是可以引用他的，所以虽然可以在部分使用zeroinitializer，但还是选择自己把所有空缺的0都补上。而且全局变量初始化的时候，需要给齐所有需要的变量，因此写了一个函数，传入数组形状和已有的初始值，会返回对齐了的数组，效果比如比如`a[100][2]={{10}}`，传入形状为`'(100)`，初始值为`'((10))`，返回一个`'((10 0 0 ... 0)(0 .. 0))'`。（Racket语言的列表装啥都行，开始就不会申请一个方方正正的数组）。
* 对于完全没有给定初值的非const数组（`a[100]={}`算上一种情况，`a[100]`这样的才算完全没给），使用的是`zeroinitializer`，反正我也不存。

#### 局部变量：

* 局部变量的初始化使用了llvm的初始化方式。数组的初始化需要分成两步，第一步是置零，第二步是对具体的某几个元素赋初值。
  * 初始的置零也是使用`memset`，但第一个参数，即块的指针，是通过`bitcast`实现的，将数组的指针转为`i32*`。然后用memset初始化，初始的长度为$4\times\Pi$​​​​​​​(各维长度)，其中4是`i32`的字节数。
  * 对给定的元素赋初值也是通过llvm的方式，这里和数组引用很像。使用的递归函数（没办法，Racket也没给我循环，我写了老半天(｡ ́︿ ̀｡)）。遇到一个花括号，先使用解引用`getelementptr`一层数组，将解引用得到的变量名传入下一层递归；当遇到数字的时候就使用`store`来赋值。

#### `LVal`：

* 这里也和LLVM一致，没有把高维数组当作一维数组实现。因为懒得自己算变成一维数组之后是第几个。LLVM那个看起来也不麻烦。
* `LVal`本来得到的就是一个指针，和之前的变量一样。如果需要LVal存的值的话，会在primary那一个`load`得到值，所以没啥矛盾。
* 在`LVal`中对变量名解引用时，先检查方括号的数量是不是和数组的维数一致，不一致则报错。接着每遇到一对方括号，就使用`getelementptr`解引用一层。