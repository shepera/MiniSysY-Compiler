# Lab8

林璐霞 18377149

## Part13

### 符号表	

函数的符号表结构是以前保留了的。函数名和全局变量共用一个符号表。只是符号表中保存的feat项的参数不一样，函数保存的是返回值和参数。

### 形式参数

* 普通的形式参数的解析还是挺简单的。解析完之后需要给每个形式参数分配一个llvm的变量名。但当需要将形式参数当作一个变量使用的时候，需要重新给这个变量名分配(`alloc`)一个空间。分配好之后将之前形式参数的值store到刚刚alloc的空间里，并且加入到符号表中。之后就可以把这个函数的形式参数当作普通的变量使用了。
* 形式参数比较麻烦的部分是数组。没有办法直接传数组，需要将数组转换成指针传给函数。因此这里需要增加一个新的指针类型。完成之后一维数组的形式参数的类型变成了`i32*`，而二维数组`[3 x [2 x i32]]`则变成了`[2 x i32] *`。这个时候形式参数store的类型就变成了指针的指针。每当需要解引用一个形式参数的时候，就需要先load一次，然后用getelementptr来完成指针偏移。然后就可以按照正常的llvm的方式使用数组了。顺便一提，这里其实也实现了任意维的数组。

### 函数调用

前面刚讲了数组需要变成指针之后再往参数里传。之前的实现是`LVal`子过程返回的是指针，由于需要使用左值的时候是`Primary`调用的`LVal`，因此在`Primary`中调用一次`load`。现在加入了数组类型，就会在`Primary`中进行判断，当遇到的是`i32*`的时候，正常使用`load`；如果遇到的是数组类型，则使用`getElementptr`。

### 返回值

函数的返回值有两种类型，`i32`和`void`。llvm要求必须有返回语句，但没规定过一个块中有多少个返回语句。因此我在每个函数的末尾都增加了一个返回语句，`ret void`或者`ret i32 0`。如果函数本来就有ret语句的话，这句多余的返回语句就会成为死代码，但也没啥影响。如果没有，就可以防止llvm报错。

